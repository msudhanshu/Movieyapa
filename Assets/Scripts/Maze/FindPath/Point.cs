	// ------------------------------------------------------------------------------
	//  <autogenerated>
	//      This code was generated by a tool.
	//      Mono Runtime Version: 4.0.30319.1
	// 
	//      Changes to this file may cause incorrect behavior and will be lost if 
	//      the code is regenerated.
	//  </autogenerated>
	// ------------------------------------------------------------------------------
	using System;
	using System.Collections.Generic;

namespace FindPath {

	public enum Edirection{
		eRight =0,
		eLeft,
		eUp,
		eDown,
	   eNoDir =-1
		
	}


	/*Point*/
	public class Point
	{
		public int x;
		public int y;
		public bool isFound;
		public Edirection restrictedDirection;
		public Edirection movedDirection;

		public Point ()
		{
			this.y = 0;
			this.x = 0;
			this.restrictedDirection = Edirection.eNoDir;
			this.isFound = false;
			
		}

		public Point (int y, int x, Edirection restrictedDir)
		{
			this.y = y;
			this.x = x;
			this.restrictedDirection = restrictedDir;
			//this.movedDirection = (Edirection)getAppositeDirection(restrictedDir);
			this.movedDirection = Edirection.eNoDir;
			this.isFound = false;
			
		}
		public Point(Point p, Edirection dir){
			this.movedDirection = dir;
			this.restrictedDirection = (Edirection)getAppositeDirection(dir);
			this.isFound = false;
			switch(dir){
			case Edirection.eRight:
				this.x = p.x+1;
				this.y = p.y;
				break;
			case Edirection.eLeft:
				this.x = p.x-1;
				this.y = p.y;
				break;
			case Edirection.eDown:
				this.x = p.x;
				this.y = p.y+1;
				break;
			case Edirection.eUp:
				this.x = p.x;
				this.y = p.y-1;
				break;
            }
		}

		public bool isSameLocation(Point p){
		if(p.x == this.x && p.y == this.y)
				return true;
			else
				return false;
		}

		Edirection getAppositeDirection(Edirection dir){
			switch(dir){
			case Edirection.eRight:
		
				return Edirection.eLeft;
				break;
			case Edirection.eLeft:
                return Edirection.eRight;
                break;
			case Edirection.eUp:
				return Edirection.eDown;
                
                break;
			case Edirection.eDown :
				return Edirection.eUp;
                
                break;
			default:
				break;
			}
			return  Edirection.eNoDir;
		
	}
}

	/*Path */
	public class Path
	{
		public List<Point> arrayPoints;
		public List<Path> arrayChildPath;
		public Path parentPath;
		public bool isFound;
		public bool isInvalid;
		public int countOfTravel =0;
		public Path ()
		{
			this.arrayPoints = new List<Point>();
			this.arrayChildPath = new List<Path>();
			this.isFound = false;
			this.isInvalid = false;
		}
		public Path (Point p)
		{
			this.arrayPoints = new List<Point>();
			this.arrayChildPath = new List<Path>();
			this.isFound = false;
			this.isInvalid = false;
			this.arrayPoints.Add(p);
		}

		public static List<MazePoint> GetPathPoints(Path path) {
			if(path==null) return null;
			List<MazePoint> pathList = new List<MazePoint>();
			GetPathPoints(path,pathList);
			return pathList;
		}

		private static void GetPathPoints(Path p, List<MazePoint> mazeList) {
			if(p!=null){
				string pathfinal="Path = ";
				for(int i =p.arrayPoints.Count -1 ; i>=0 ; i--){
					Point pc = p.arrayPoints[i];
					mazeList.Add(new MazePoint(pc.x,pc.y));
				}
				GetPathPoints(p.parentPath,mazeList);
			}

		}

	}


}